---
title: Compiling a ROOT macro with ACLiC into libraries
layout: single
sidebar:
  nav: "manual"
toc: true
toc_sticky: true
---


You can compile, link and dynamically load a macro using the C++ compiler and linker.

Using the compiler allows using language constructs that are not fully supported by Cling.

ACLiC (*Compiling Your Code*) will build a dictionary and a shared library from your C++ macro,
using the compiler and the compiler options that were used to compile the ROOT executable.

You do not have to write a Makefile remembering the correct compiler options, and you do not
have to exit ROOT.

## Building a shared library

Before you can compile your interpreted macro, you need to add the include statements for
the classes used in the macro. Only then you can build and load a shared library containing
your macro.

To build a shared library from a ROOT macro, type:

```
   root[] .L MyScript.C+
```

The `+` option generates a shared library. The name of the shared library is the filename
where the dot before the extension is replaced by an underscore and the shared library
extension is added.

### Example

On most platforms, `hsimple.cxx` will generate `hsimple_cxx.so`.

The `+` command rebuilds the library only if the ROOT macro or any of the files it includes
are newer than the library.


When checking the timestamp, ACLiC generates a dependency file, which name is the same as
the library name, just replacing the 'so' extension by the extension '`d`'.

### Example

On most platforms, `hsimple.cxx ` will generate `hsimple_cxx.d`.

## Setting the include path

The `$ROOTSYS/include` directory is automatically appended to the include path.

To get the include path, type:

```
   root[] .include
```

To append the include path, type:
```
   root[] .include $HOME/mypackage/include
```

Append the following line in the ROOT macro to include the include path:

```
   gSystem->AddIncludePath(" -I$HOME/mypackage/include")
```

To overwrite an existing include path, type:

```
   gSystem->SetIncludePath(" -I$HOME/mypackage/include")
```

To add a static library that should be used during linking, type:

```
   gSystem->AddLinkedLibs("-L/my/path -l*anylib*");
```

For adding a shared library, you can load it before you compile the ROOT macros, by

```
   gSystem->Load("mydir/mylib");
```

## Generating dictionaries

You can define what is added to the dictionary generated by ACLiC.

Add the following line and the end of the ROOT macro:

```
      #if defined(__ROOTCLING__)
      #pragma link C++ class MyOtherClass;
      #endif
```

## Compiling a ROOT macro

You can compile a ROOT macro with:

  - default optimizations

  - optimizations

  - debug symbols

Compilation ensures that the shared library is rebuilt.

> **Note**
>
> Do not call ACLiC with a ROOT macro that has a function called `main()`.

To compile a ROOT macro with default optimizations, type:

```
      root[] .L MyScript.C++g
```

To compile a ROOT macro with optimizations, type:
```
      root[] .L MyScript.C++O
```

To compile a ROOT macro with debug symbols, type:

```
      root[] .L MyScript.C++
```

ACLiC executes the following steps:

  1. Calling rootcling to create a dictionary.

  2. Calling the compiler to build the shared library from the ROOT macro.

  3. If there are errors, it calls the compiler to build a dummy executable to clearly
     report the unresolved symbols.

ACLiC adds the classes and functions declared in included files with the same name as the
ROOT macro files with one of following extensions: `.h`, `.hh`, `.hpp`, `.hxx`,` .hPP`, `.hXX`.
This means that, by default, you cannot combine ROOT macros from different files into one
library by using `#include` statements; you will need to compile each ROOT macro separately.
